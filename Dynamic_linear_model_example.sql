/*Build a dynamic linear model to predict next month's operating income using the data from the past 12 consecutive months*/
/*Author: Robert Lendzion*/

/*Let's assume that OP for every month is ~5% higher vs prior month, so we expect actual results to be linear as well, with a slope of ~5%!
The input data could look like this:

ROW_ID | REPORTING_PERIOD | YYYYMM | OPERATING_INCOME
-----------------------------------------------------
145980 | 30-NOV-2019      | 201911 | 	    261500000
145979 | 30-NOV-2019      | 201910 | 	    245999000
...
145898 | 31-OCT-2019      | 201910 | 	    240000000
145897 | 31-OCT-2019      | 201909 | 	    228900000
...
145227 | 31-JUL-2018      | 201806 | 	     -1129000
145226 | 31-JUL-2018      | 201806 | 	     85000000

REPORTING_PERIOD is put here to make things more spicy! Let's imagine that the operating income is adjusted every month (in previous years new records with adjustment value used to be created) because of late entries into the system.
The business people would like to keep track of those changes, therefore, the adjusted historical data is appended to the latest month's result with a new reporting date.*/

SET NUMW 20;
WITH C1 AS 
	(SELECT * FROM (SELECT YYYYMM, ROW_NUMBER() OVER (ORDER BY YYYYMM) AS X, SUM(OPERATING_INCOME) AS Y /*Target variable*/
	FROM MY_SCHEMA.CFO_DATA
	WHERE REPORTING_PERIOD = LAST_DAY(ADD_MONTHS(SYSDATE),-1)) 
	AND YYYYMM BETWEEN TO_NUMBER(TO_CHAR(ADD_MONTHS(SYSDATE,-12),'YYYYMM')) AND TO_NUMBER(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYYMM'))) /*The code will not break if we decide to use only 6 months of data*/
	GROUP BY YYYYMM)),
C2 AS 
	(SELECT TO_NUMBER(TO_CHAR(ADD_MONTHS(TO_DATE((SELECT TO_NUMBER(MAX(YYYYMM)) FROM C1),'YYYYMM'),1),'YYYYMM')) AS YYYYMM, 
	(SELECT TO_NUMBER(MAX(X)) FROM C1)+1 AS X, NULL AS Y FROM DUAL), /*Add X for which we are going to predict Y*/
C3 AS 
	(SELECT * FROM C1 UNION SELECT * FROM C2),
C4 AS 
	(SELECT YYYYMM, X, Y,
	AVG(CASE WHEN Y IS NOT NULL THEN X ELSE NULL END) OVER (ORDER BY X ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS X_AVG,
	AVG(Y) OVER (ORDER BY X ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS Y_AVG,
	X-AVG(CASE WHEN Y IS NOT NULL THEN X ELSE NULL END) OVER (ORDER BY X ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS X_DEV_FROM_MEAN,
	POWER(X-AVG(CASE WHEN Y IS NOT NULL THEN X ELSE NULL END) OVER (ORDER BY X ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING),2) AS X_DEV_FROM_MEAN_SQRD,
	Y-AVG(Y) OVER (ORDER BY X ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS Y_DEV_FROM_MEAN,
	(X-AVG(CASE WHEN Y IS NOT NULL THEN X ELSE NULL END) OVER (ORDER BY X ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) * (Y-AVG(Y) OVER (ORDER BY X ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) AS X_Y_DEV_PRODUCT
	FROM C3
	GROUP BY YYYYMM, X, Y),
C5 AS 
	(SELECT C4.*,
	SUM(CASE WHEN Y IS NOT NULL THEN X_DEV_FROM_MEAN_SQRD ELSE 0 END) OVER (ORDER BY X ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS SUM_X_DEV_FROM_MEAN_SQRD,
	SUM(X_Y_DEV_PRODUCT) OVER (ORDER BY X ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) / (SUM(CASE WHEN Y IS NOT NULL THEN X_DEV_FROM_MEAN_SQRD ELSE 0 END) OVER (ORDER BY X ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) AS SLOPE
	FROM C4
	GROUP BY YYYYMM, X, Y, X_AVG, Y_AVG, X_DEV_FROM_MEAN, X_DEV_FROM_MEAN_SQRD, Y_DEV_FROM_MEAN, X_Y_DEV_PRODUCT),
/*Final calculations*/
SELECT YYYYMM, X, Y,
ROUND(X*SLOPE + (Y_AVG-SLOPE*X_AVG),2) AS GUESS,
ROUND(Y-(X*SLOPE + (Y_AVG-SLOPE*X_AVG),2)) AS RESIDUALS /*Residuals can be used to assess the accuracy of the model*/
FROM C5;